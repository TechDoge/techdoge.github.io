---
layout:     post
title:      Java多线程
subtitle:   知识点总结
date:       2019-06-13
author:     ctrlcoder
header-img: 
catalog: true
tags:
    - Java
typora-root-url: ..
---

### 进程和线程



#### 进程

每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。

#### 线程

线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中是可以有多个线程的。

#### 进程和线程的关系

 ![1560411923750](/img/assets_2019/1560411923750.png)

一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器**、**虚拟机栈** 和 **本地方法栈**。(JDK1.8的新特性以后了解)

- **程序计数器**

  记录当前要执行的指令地址。

  私有是为了线程切换能恢复到正确的执行位置。

  如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。

- **栈**

  每个线程都有自己的栈资源，私有保证线程中的局部变量不被别的线程访问到。

  - 虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
  - 本地方法栈：为虚拟机使用到的 Native 方法服务。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

- **堆**

  被进程中的所有线程的共享，是进程创建时分配的，堆里面主要存放使用new操作创建的对象实例。

- **方法区**

  用来存放JVM加载的类、常量、及静态变量等信息，也是线程共享的。

#### 并发和并行

- 并行：指两个或多个事件在同一时刻发生（同时发生），多个处理器或多核处理器同时处理多个任务。
- 并发：指两个或多个事件在同一个时间段内发生，多个任务在同一个CPU核上，按细分的时间片轮流执行，从逻辑上来看那些任务是同时执行。





### 线程的创建



#### 继承Thread类并重写run的方法

当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。

```java
public class MyThread extends Thread {
    //重写run方法
    public void run() {
        // ...
    }
}

public static void main(String[] args) {
    //创建线程
    MyThread mt = new MyThread();
    //启动线程
    mt.start();
}
```

#### 实现Runnable接口的run方法

通过 Thread 调用 start() 方法来启动线程。

```java
public class RunnableTask implements Runnable {
    public void run() {
        // ...
    }
}
public static void main(String[] args) {
    RunnableTask task = new RunnableTask();
    new Thread(task).start();
}
```

#### 实现Callable接口的call方法

在main函数内首先创建一个FutrueTask对象，然后使用创建的FutrueTask对象作为任务创建一个线程并且启动它，最后通过FutureTask.get()等待任务执行完毕并返回结果。

```java
public class CallerTask implements Callable<String> {
    public String call() {
        return "hello"
    }
}
public static void main(String[] args) throws InterruptedException {
    //创建异步任务
    FutureTask<Integer> ft = new FutureTask<>(new CallerTask);
    //启动线程
    new Thread(ft).start();
    try{
    String result = ft.get();
    System.out.println(result);
    }catch(ExecutionException e){
        e.printStackTrace();
    }
}
```

#### 比较

使用继承方式的好处是方便传参，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递哦，而如果使用Runnable方式，则只能使用主线程里被声明为final的变量。不好的地方是Java不支持多继承，如果继承了Thread类，那么子类不能再继承其他类，而Runnable则没有这个限制。前两种方式都没办法拿到任务的返回结果，但是Callable方式可以。





### 线程状态



Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态。

![1560423851400](/img/assets_2019/1560423851400.png)

#### Timed Waiting（计时等待）

无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。

调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。

调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。

睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。

阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。

| 进入方法                                 | 退出方法                                        |
| ---------------------------------------- | ----------------------------------------------- |
| Thread.sleep() 方法                      | 时间结束                                        |
| 设置了 Timeout 参数的 Object.wait() 方法 | 时间结束 / Object.notify() / Object.notifyAll() |
| 设置了 Timeout 参数的 Thread.join() 方法 | 时间结束 / 被调用的线程执行完毕                 |
| LockSupport.parkNanos() 方法             | LockSupport.unpark(Thread)                      |
| LockSupport.parkUntil() 方法             | LockSupport.unpark(Thread)                      |

#### BLOCKED（锁阻塞）

线程A与线程B代码中使用同一锁，如果线程A获 取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。

![1560424161917](/img/assets_2019/1560424161917.png)

#### Waiting（无限等待）

![1560424291644](/img/assets_2019/1560424291644.png)

| 进入方法                                   | 退出方法                             |
| ------------------------------------------ | ------------------------------------ |
| 没有设置 Timeout 参数的 Object.wait() 方法 | Object.notify() / Object.notifyAll() |
| 没有设置 Timeout 参数的 Thread.join() 方法 | 被调用的线程执行完毕                 |
| LockSupport.park() 方法                    | LockSupport.unpark(Thread)           |

#### 状态转换图

![1560424523051](/img/assets_2019/1560424523051.png)

