---
layout:     post
title:      hashcode和equals方法
subtitle:   
date:       2019-06-18
author:     ctrlcoder
header-img: 
catalog: true
tags:
    - Java
typora-root-url: ..
---

# 哈希表

## ## Leetcode387

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回-1。

``` java
class Solution{
    public int firstUniqCHar(String s){
        int[] freq =  new int[26];
        for(int i = 0 ; i < s.length() ; i++)
            freq[s.charAt[i]-'a']++;
        for(int i = 0 ; i < s.length() ; i++)
            if(freq[s.charAt(i)-'a'] == 1)
                return i;
    }
    return -1;
}
```

- 哈希表：每一个字符都和一个索引相对应
- 哈希函数：将”键“转换为“索引”
- 哈希冲突：很难保证每一个"键"通过哈希函数的转换对应不同的“索引“

**哈希表充分体现了算法设计领域的经典思想：空间换时间。**

**“键”通过哈希函数得到的“索引”分布约均匀越好。**

#### 哈希函数的设计

- 小范围正整数直接使用，小范围负整数进行便宜
- 大整数的解决办法：模一个素数

- 浮点数在计算机都是32位或64位的二进制表示，只不过计算机解析成了浮点数->转成整形处理

- 字符串

  ![1560852311626](/img/assets_2019/1560852311626.png)

- 复合类型

![1560852336764](/img/assets_2019/1560852336764.png)

##### 设计原则

- 一致性：如果a==b,则hash(a)==hash(b)
- 高效性：计算高效简便
- 均匀性：哈希值均匀分布

## Java的hashCode和equals方法

equals等价于`==`,而`==`运算符是判断两个对象是不是同一个对象，即他们的**地址是否相等**。而覆写equals更多的是追求两个对象在**内容相等**。

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

### equals覆写准则

> **自反性**：对于任何非空引用值 x，x.equals(x) 都应返回 true。
>
> **对称性**：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。
>
> **传递性**：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true， 并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。
>
> **一致性**：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false， 前提是对象上 equals 比较中所用的信息没有被修改。
>
> **非空性**：对于任何非空引用值 x，x.equals(null) 都应返回 false。

**equals函数里面一定要是Object类型作为参数**

