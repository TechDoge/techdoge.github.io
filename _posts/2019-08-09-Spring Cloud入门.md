---
layout:     post
title:      Spring Cloud入门
subtitle:   
date:       2019-08-09
author:     ctrlcoder
header-img: 
catalog: true
tags:
    - 微服务
typora-root-url: ..
---

> Spring Cloud 并不是一个具体的框架，大家可以把它理解成为一个工具箱，它提供的各类工具，可以帮助我们快速构建分布式系统。Spring Cloud 的各个项目基于Spring Boot ，将 Netflix 的多个框架进行封装，并且通过自动配置的方式将这些框架绑定到 Spring 的环境中，从而使得这些框架变得简单。由于 Spring Boot 的这种简便性，使得我们在使用Spring Cloud时，很容易将 Netflix 各个框架整合到我的项目中。

## 基本概念

**微服务**：微服务简单说，**一个  Spring Boot  就是一个 微服务**，并且这个 Spring Boot  做的事情很单纯。 比如 product-service 这个项目，就可以拆成两个微服务，分别是数据微服务，和视图微服务，其实就是俩 Spring Boot , 只是各自做的事情都更单纯。

**分布式**： 简单说，原来是在一个 Spring Boot  里就完成的事情，现在分布在多个 Spring Boot  里做，这就是初步具备 分布式雏形了。

**集群**：原来数据微服务只有这一个 Spring Boot , 现在做同样数据微服务的，有两个 Spring Boot , 他们提供的功能一模一样，只是端口不一样，这样就形成了集群。如果 8001 挂了，还有 8002 继续提供微服务，这就叫做**高可用** 。

![1565424983520](/img/assets_2019/1565424983520.png)

## 核心组件概念

### 1. 注册中心：Eureka

在 SpringCloud 体系中，最常用的注册中心就是 Eureka。任何服务启动以后，都会把自己注册到Eureka 的注册表中；当服务死亡的时候，也会通知 Eureka。

![img](/img/assets_2019/16c4c1eebdb5e0e4)

当服务A想要找服务B的时候，只需要问一下Eureka Server就可以了。

为了达到这个目的，还是要有一部分工作量的。且看下图。这个注册动作，是由一个叫做Eureka Client的组件来完成的。服务启动和关闭的时候，会通过这个组件推销自己；而当服务A想要调用服务B的时候，直接问Eureka Server就可以了。服务A拿到结果后，会把结果缓存在本地的注册表里。

你可以认为是一个拷贝。所以Eureka Server死掉后，并不影响服务A找到服务B。

![img](/img/assets_2019/16c4c1f0eeafe77b)

### 2.负载均衡组件：Ribbon

现在问题来了。服务A拿到服务B的实例列表以后，发现有两台`10.0.0.12`和`10.0.0.16`

接下来麻烦了，该调哪台机器呢？这就是 SpringCloud 中组件Ribbon的作用。其实`Round Robin`是一个通用的计算机术语。它是最常用的负载均衡策略，请求会均匀的分配给后面的每台服务器。

Ribbon 工作时，会做下面四件事：

1. 优先选择在一个Zone且负载较少的Eureka Server，进行连接。
2. 定期从Eureka更新、过滤服务和实例列表。
3. 根据负载均衡策略，从注册表中选择一个真正的实例地址。
4. 通过 RestClient 对服务发起调用。


![img](/img/assets_2019/16c4c1f4d09fc25f)

Ribbon 背后，还是采用的 Http 协议进行交互, Ribbon 的 Filter 会查找某服务，并替换成相应的实例地址。

**策略** : Ribbon 不仅仅提供了轮询的策略，还有其他的，比如：

1、随机Random 2、根据响应时间加权 3、自定义

拿轮询来说，最终的选择逻辑就在 RoundRobinRule 类中。

### 3. 为简化代码而生：Feign

可以看到，Ribbon 需要自己构建 http 请求，模拟 http请求然后使用 RestTemplate 发送给其他服务，步骤相当繁琐。而且返回类型不安全，也表达不出什么语义。

Feign 得益于 Java 的动态代理机制，最终封装出一套简洁的接口调用方式，将需要调用的其他服务的方法定义成抽象方法即可，不需要自己构建 http 请求。

![img](/img/assets_2019/16c4c1ff6608c263)

首先，Feign会根据 @FerignClient 注解，通过动态代理，创建一个动态代理类。接下来，你只要通过调用接口的方式，就可以构造上面提到的 Ribbon 调用参数，这个过程会自动填充。最后，通过构造的Ribbon请求，发起真正的调用，并通过反射组装返回值。

所以，Feign 只是一层皮，最终还是要通过 Ribbon 进行调用。在我看来，把 Ribbon 和 Feign 成一个组件，也是合理的。

它们有一个比较通用的名词，就叫做 RPC（远程调用）。

### 4. 熔断器：Hystrix

对于某个业务这种不是链路上必备的服务提供者，要有一个手段，让它在发生问题的时候，隔离它一段时间。负责这个功能的组件，就叫做 Hystrix。

Hystrix 对每个服务开了一个线程池，并有比较复杂的规则，来控制这些出问题的服务的行为。

这个过程，就叫熔断。就像电源一样，出了问题，先切断保险丝，别把电器给烧了。

### 5. 此网关非彼网关：zuul

网关的职责：

1. 安全认证。提供统一的认证方式和鉴权功能，避免重复开发。
2. 熔断，限流。针对问题服务，进行熔断操作；对流量进行预估，限制访问。
3. 日志监控。统一流量入口，进行流量分析和监控。
4. 屏蔽内部细节，对外提供一致的接口。
5. 实现灰度。使用自定义策略实现分流，达到测试的目的。

![img](/img/assets_2019/16c4c20476f47f6b)

可以看到，我们平常用的 nginx，就可以当作网关。但对于微服务来说，nginx 的配置实在是太麻烦了。不是说 nginx 功能不够强大，而是因为它们不是一个体系的，就存在整合成本。

zuul 就不一样了，它和 Spring Cloud 的其他组件，是一家子的。一家子的，当然会特殊照顾。Zuul 本身就是一个 Servlet，外部请求经过一系列 Filter 后，会达到真正的服务。上面说的熔断器，就是高度集成的。



### 整合

**3个关键点：**

1. 服务注册中心，统一管理所有服务的信息，默认组件是 Eureka。
2. RPC，网络通信组件，服务A怎么调用服务B。在 SpringCloud 中，就是 Ribbon + Feign。
3. 网关，拆分的服务怎么暴露接口，最终见人的样子。 默认组件是 Zuul。



![img](/img/assets_2019/16c4c208fc90eb03)



