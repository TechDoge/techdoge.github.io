---
layout:     post
title:      Java多线程
subtitle:   知识点总结
date:       2019-06-13
author:     ctrlcoder
header-img: 
catalog: true
tags:
    - Java
typora-root-url: ..
---

### 进程和线程

#### 进程

每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。



#### 线程

线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中是可以有多个线程的。



#### 进程和线程的关系

### ![1560411923750](/img/assets_2019/1560411923750.png)

一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器**、**虚拟机栈** 和 **本地方法栈**。(JDK1.8的新特性以后了解)

- **程序计数器**

  记录当前要执行的指令地址。

  私有是为了线程切换能恢复到正确的执行位置。

  如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。

- **栈**

  ​	每个线程都有自己的栈资源，私有保证线程中的局部变量不被别的线程访问到。

  - 虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
  - 本地方法栈：为虚拟机使用到的 Native 方法服务。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

- **堆**

  被进程中的所有线程的共享，是进程创建时分配的，堆里面主要存放使用new操作创建的对象实例。

- **方法区**

  用来存放JVM加载的类、常量、及静态变量等信息，也是线程共享的。



#### 并发和并行

- 并行：指两个或多个事件在同一时刻发生（同时发生），多个处理器或多核处理器同时处理多个任务。
- 并发：指两个或多个事件在同一个时间段内发生，多个任务在同一个CPU核上，按细分的时间片轮流执行，从逻辑上来看那些任务是同时执行。



### 线程的创建

#### 继承Thread类并重写run的方法

当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。

```java
public class MyThread extends Thread {
    //重写run方法
    public void run() {
        // ...
    }
}

public static void main(String[] args) {
    //创建线程
    MyThread mt = new MyThread();
    //启动线程
    mt.start();
}
```



#### 实现Runnable接口的run方法

通过 Thread 调用 start() 方法来启动线程。

```java
public class RunnableTask implements Runnable {
    public void run() {
        // ...
    }
}
public static void main(String[] args) {
    RunnableTask task = new RunnableTask();
    new Thread(task).start();
}
```



#### 实现Callable接口的call方法

在main函数内首先创建一个FutrueTask对象，然后使用创建的FutrueTask对象作为任务创建一个线程并且启动它，最后通过FutureTask.get()等待任务执行完毕并返回结果。

```java
public class CallerTask implements Callable<String> {
    public String call() {
        return "hello"
    }
}
public static void main(String[] args) throws InterruptedException {
    //创建异步任务
    FutureTask<Integer> ft = new FutureTask<>(new CallerTask);
    //启动线程
    new Thread(ft).start();
    try{
    String result = ft.get();
    System.out.println(result);
    }catch(ExecutionException e){
        e.printStackTrace();
    }
}
```



#### 比较

使用继承方式的好处是方便传参，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递哦，而如果使用Runnable方式，则只能使用主线程里被声明为final的变量。不好的地方是Java不支持多继承，如果继承了Thread类，那么子类不能再继承其他类，而Runnable则没有这个限制。前两种方式都没办法拿到任务的返回结果，但是Callable方式可以。

